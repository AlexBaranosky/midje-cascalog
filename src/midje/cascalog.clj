(ns midje.cascalog
  (:use midje.sweet
        [clojure.set :only (difference union)]
        [cascalog.testing :only (process?-)]
        [cascalog.io :only (log-levels)]))

(def mocking-forms #{'against-background 'provided})
(def checker-forms #{'contains 'just 'has-prefix 'has-suffix})

(defn- clause-from-set? [set x]
  (when (coll? x)
    (set (first x))))

(def ^{:doc "Returns true if the supplied form (or sequence) is a
  midje `provided` or `against-background` clause, false otherwise."
       :private true}
  mocking-form?
  (partial clause-from-set? mocking-forms))

(def ^{:doc "Returns true if the supplied form (or sequence) is a midje
  collection checker form, false otherwise."
       :private true}
  checker-form?
  (partial clause-from-set? checker-forms))

(defn- extract-mockers
  "Returns a vector of two sequences, obtained by splitting the
  supplied `coll` into midje forms and rest."
  [coll]
  ((juxt filter remove) mocking-form? coll))

(defn fact-line
  "Returns a syntax-quoted list representing the guts of a midje fact
  for the supplied cascalog query and result.

  Note that this fact will check that all tuples inside of `result`
  are generated by the supplied query, in any order. Log Level "
  [result query ll]
  (let [process #(first (second (apply process?- %&)))
        [result checker] (if (checker-form? result)
                           [(second result) `~result]
                           [result (list `just result :in-any-order)])]
    `((~process ~@(when ll [ll]) ~result ~query) => ~checker)))

(defn- fact-line
  "Returns a syntax-quoted list representing the guts of a midje fact
  for the supplied cascalog query and result.

  Note that this fact will check that all tuples inside of `result`
  are generated by the supplied query, in any order. Log Level "
  [result query ll]
  (let [process #(first (second (apply process?- %&)))
        [result checker] (if (checker-form? result)
                           [(second result) `~result]
                           [result (list `just result :in-any-order)])]
    `((~process ~@(when ll [ll]) ~result ~query) => ~checker)))

(defn- process-bindings
  "Accepts a set of fact bindings and returns a 2-tuple of log level &
  remaining bindings. (The log level is an optional first argument,
  and must be a keyword.)"
  [[ll & more :as bindings]]
  (if (contains? log-levels ll)
    [ll more]
    [nil bindings]))

(defn- build-fact?-
  "Accepts a sequence of fact?- bindings and a midje \"factor\" --
  `fact`, or `future-fact`, for example -- and returns a syntax-quoted
  version of the sequence with all result-query pairs replaced with
  corresponding midje fact-result pairs. For example:

  (build-fact?- '(\"string\" [[1]] (<- [[?a]] ([[1]] ?a))) `fact)
   ;=> (fact <results-of-query> => (just [[1]] :in-any-order)"
  [bindings factor]
  (let [[ll bindings] (process-bindings bindings)]
    `(~factor
      ~@(loop [[x y & more :as forms] bindings, res []]
          (cond (not x) res
                (or (string? x)
                    (mocking-form? x)) (recur (rest forms) (conj (vec res) x))
                :else (->> (fact-line x y ll)
                           (concat res)
                           (recur more)))))))

(defn- build-fact?<-
  "Similar to `build-fact?-`; args must contain a result sequence, a
  query return arg vector, and any number of predicates. The last
  forms can be midje provided or background clauses."
  [args factor]
  (let [[ll :as args] (remove string? args)
        [begin args] (if (keyword? ll)
                       (split-at 2 args)
                       (split-at 1 args))
        [m body] (extract-mockers args)]
    `(~factor ~@begin (cascalog.api/<- ~@body) ~@m)))

(defmacro fact?- [& bindings] (build-fact?- bindings `fact))
(defmacro fact?<- [& args] (build-fact?<- args `fact?-))

(defmacro future-fact?- [& bindings] (build-fact?- bindings `future-fact))
(defmacro future-fact?<- [& args] (build-fact?<- args `future-fact?-))

(defmacro pending-fact?- [& bindings] (build-fact?- bindings `pending-fact))
(defmacro pending-fact?<- [& args] (build-fact?<- args `pending-fact?-))

;; ## Custom Checkers
;;
;; The above macros match the syntax of Cascalog's clojure.test
;; integration, but doesn't really look familiar to the rest of the
;; Midje facts you'll be writing. Midje-Cascalog remedies this by
;; implementing four custom checkers to use in your facts:
;;
;; * produces
;; * produces-some
;; * produces-prefix
;; * produces-suffix
;;
;; These act (respectively) like `just`, `contains`, `has-prefix` and
;; `has-suffix` do for normal collections. Use them like this:

;; (fact "memory sources should produce themselves."
;;   (memory-source-tap [[1]]) => (produces [[1]]))
;;
;;
;; Unlike `just` and `contains`, `produces` and `produces-some` make
;; the default assumption that output from the checked generator will
;; be unordered.
;;
;; To test for an ordered set of tuples with `produces` or
;; `produces-some`, use the `:in-order` keyword argument:
;;
;;    (produces [[10] [11]] :in-order)
;;
;; When `:in-order` is used with `produces-some`, the checker will
;; assume that gaps are okay. To test for an ordered subset of tuples,
;; use both `:in-order` and `:no-gaps` as arguments:
;;
;;    (produces-some [[10] [11]] :in-order :no-gaps)
;;
;; Using `:no-gaps` without `:in-order` is allowed but has no effect.

(defn- execute
  "Accepts a subquery and a sequence of result tuples and returns the
  tuple sequence that results from executing the supplied
  subquery. Optionally, `execute` takes a sequence of arguments;
  currently only a keyword argument in the first position for
  log-level is supported."
  [tuples query opts]
  (let [process (comp first second process?-)
        [ll _] (process-bindings opts)]
    (if ll
      (process ll tuples query)
      (process tuples query))))

(def log-level-set
  (set (keys log-levels)))

(defn- valid-options?
  "Returns false if supplied-opts contains any item not present in
  `permitted-opts` or `log-level-set`, true otherwise."
  [permitted-opts supplied-opts]
  (empty? (difference (set supplied-opts)
                      log-level-set
                      (set permitted-opts))))

(defn wrap-checker
  "Accepts two arguments:

  `checker-fn`: a midje collection checker (just or contains, for
  example). This checker-fn will be primed with the expected set of
  tuples for the query being tested.

  `opt-map` (optional): map of some set of allowed keyword arguments
  for the checker we're generating to the corresponding arguments to
  the supplied `checker-fn`.

  Returns a function that accepts a sequence of result tuples and
 optional arguments and returns a chatty checker tuned for said
 arguments. See `produces` and `produces-some` for usage examples."
  [checker-fn & [opt-map]]
  {:pre [(every? set? (keys opt-map))]}
  (let [opt-map    (or opt-map {})
        valid-opts (apply union (keys opt-map))]
    (fn [tuples & opts]
      {:pre [(valid-options? valid-opts opts)]}
      (let [opt-set  (-> (set opts) (difference log-level-set))
            options  (or (opt-map opt-set) [])
            check-fn (apply checker-fn tuples options)]
        (chatty-checker
         [query]
         (check-fn (execute tuples query opts)))))))

;; With our fun function-generating-function-generating functions
;; behind us, we can move on to the meaty definitions of our Cascalog
;; collection checkers.

(def produces
  (wrap-checker just
                {#{:in-order} #{}
                 #{}          #{:in-any-order}}))

(def produces-some
  (wrap-checker contains
                {#{:in-order :no-gaps} #{}
                 #{:in-order}          #{:gaps-ok}
                 #{}                   #{:in-any-order :gaps-ok}}))

(def produces-prefix
  (wrap-checker has-prefix))

(def produces-suffix
  (wrap-checker has-suffix))
