(ns midje.cascalog
  (:use midje.sweet
        [cascalog.testing :only (process?-)]
        [cascalog.io :only (log-levels)]))

(def mocking-forms #{'against-background 'provided})
(def checker-forms #{'contains 'just 'has-prefix 'has-suffix})

(defn clause-from-set? [set x]
  (when (coll? x)
    (set (first x))))

(def ^{:doc "Returns true if the supplied form (or sequence) is a
  midje `provided` or `against-background` clause, false otherwise."}
  mocking-form?
  (partial clause-from-set? mocking-forms))

(def ^{:doc "Returns true if the supplied form (or sequence) is a midje
  collection checker form, false otherwise."}
  checker-form?
  (partial clause-from-set? checker-forms))

(defn extract-mockers
  "Returns a vector of two sequences, obtained by splitting the
  supplied `coll` into midje forms and rest."
  [coll]
  ((juxt filter remove) mocking-form? coll))

(defn fact-line
  "Returns a syntax-quoted list representing the guts of a midje fact
  for the supplied cascalog query and result.

  Note that this fact will check that all tuples inside of `result`
  are generated by the supplied query, in any order. Log Level "
  [result query ll]
  (let [process #(first (second (apply process?- %&)))
        [result checker] (if (checker-form? result)
                           [(second result) `~result]
                           [result (list `just result :in-any-order)])]
    `((~process ~@(when ll [ll]) ~result ~query) => ~checker)))

(defn process-bindings
  "Accepts a set of fact bindings and returns a 2-tuple of log level &
  remaining bindings. (The log level is an optional first argument,
  and must be a keyword.)"
  [[ll & more :as bindings]]
  (if (contains? log-levels ll)
    [ll more]
    [nil bindings]))

(defn- build-fact?-
  "Accepts a sequence of fact?- bindings and a midje \"factor\" --
  `fact`, or `future-fact`, for example -- and returns a syntax-quoted
  version of the sequence with all result-query pairs replaced with
  corresponding midje fact-result pairs. For example:

  (build-fact?- '(\"string\" [[1]] (<- [[?a]] ([[1]] ?a))) `fact)
   ;=> (fact <results-of-query> => (just [[1]] :in-any-order)"
  [bindings factor]
  (let [[ll bindings] (process-bindings bindings)]
    `(~factor
      ~@(loop [[x y & more :as forms] bindings, res []]
          (cond (not x) res
                (or (string? x)
                    (mocking-form? x)) (recur (rest forms) (conj (vec res) x))
                :else (->> (fact-line x y ll)
                           (concat res)
                           (recur more)))))))

(defn- build-fact?<-
  "Similar to `build-fact?-`; args must contain a result sequence, a
  query return arg vector, and any number of predicates. The last
  forms can be midje provided or background clauses."
  [args factor]
  (let [[ll :as args] (remove string? args)
        [begin args] (if (keyword? ll)
                       (split-at 2 args)
                       (split-at 1 args))
        [m body] (extract-mockers args)]
    `(~factor ~@begin (cascalog.api/<- ~@body) ~@m)))

(defmacro fact?- [& bindings] (build-fact?- bindings `fact))
(defmacro fact?<- [& args] (build-fact?<- args `fact?-))

(defmacro future-fact?- [& bindings] (build-fact?- bindings `future-fact))
(defmacro future-fact?<- [& args] (build-fact?<- args `future-fact?-))

(defmacro pending-fact?- [& bindings] (build-fact?- bindings `pending-fact))
(defmacro pending-fact?<- [& args] (build-fact?<- args `pending-fact?-))

;; ## Produces and Friends
;;
;; The following functions attempt to create a more natural set of
;;midje checkers that allow the user to write facts like this:
;;
;; (fact "memory sources should produce themselves."
;;   (memory-source-tap [[1]]) => (produces [[1]]))
;;
;; The work here isn't complete; I'll wait for a bit more input before
;; I proceed.

(defn mk-checker
  "Returns a tuple collection checker for the supplied set of expected
  tuples, tuned with the provided sequence of arguments."
  [expected opts]
  (just expected :in-any-order))

(defn execute
  "Accepts a subquery and a sequence of result tuples and returns the
  tuple sequence that results from executing the supplied
  subquery. Optionally, `execute` takes a sequence of arguments;
  currently only a keyword argument in the first position for
  log-level is supported."
  [tuples query opts]
  (let [process (comp first second process?-)
        [ll _] (process-bindings opts)]
    (if ll
      (process ll tuples query)
      (process tuples query))))

(defn produces
  "Returns a checker that expects to be used against a
  subquery:

   (fact <subquery> => (produces <result-seq>))

   For example:

   (fact (some-subquery [[1]]) => (produces [[2]]))

   `produces` currently only checks that the exact result tuple-set
   was produced in any order. `produces` takes an optional set of
   keyword arguments after the result vector. Currently only
   log-levels are supported."
  [expected & opts]
  (chatty-checker
   [actual]
   ((mk-checker expected opts) (execute expected actual opts))))
